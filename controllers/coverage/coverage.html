
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>controllers: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/3scale/saas-operator/controllers/apicast_controller.go (0.0%)</option>
				
				<option value="file1">github.com/3scale/saas-operator/controllers/autossl_controller.go (0.0%)</option>
				
				<option value="file2">github.com/3scale/saas-operator/controllers/backend_controller.go (0.0%)</option>
				
				<option value="file3">github.com/3scale/saas-operator/controllers/corsproxy_controller.go (0.0%)</option>
				
				<option value="file4">github.com/3scale/saas-operator/controllers/echoapi_controller.go (0.0%)</option>
				
				<option value="file5">github.com/3scale/saas-operator/controllers/mappingservice_controller.go (0.0%)</option>
				
				<option value="file6">github.com/3scale/saas-operator/controllers/reconciler_config.go (100.0%)</option>
				
				<option value="file7">github.com/3scale/saas-operator/controllers/redisshard_controller.go (0.0%)</option>
				
				<option value="file8">github.com/3scale/saas-operator/controllers/sentinel_controller.go (0.0%)</option>
				
				<option value="file9">github.com/3scale/saas-operator/controllers/system_controller.go (0.0%)</option>
				
				<option value="file10">github.com/3scale/saas-operator/controllers/twemproxyconfig_controller.go (0.0%)</option>
				
				<option value="file11">github.com/3scale/saas-operator/controllers/zync_controller.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">/*
Copyright 2021.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package controllers

import (
        "context"

        marin3rv1alpha1 "github.com/3scale-ops/marin3r/apis/marin3r/v1alpha1"
        saasv1alpha1 "github.com/3scale/saas-operator/api/v1alpha1"
        "github.com/3scale/saas-operator/pkg/generators/apicast"
        "github.com/3scale/saas-operator/pkg/reconcilers/workloads"
        "github.com/go-logr/logr"
        grafanav1alpha1 "github.com/grafana-operator/grafana-operator/v4/api/integreatly/v1alpha1"
        monitoringv1 "github.com/prometheus-operator/prometheus-operator/pkg/apis/monitoring/v1"
        appsv1 "k8s.io/api/apps/v1"
        autoscalingv2 "k8s.io/api/autoscaling/v2"
        corev1 "k8s.io/api/core/v1"
        policyv1 "k8s.io/api/policy/v1"
        "k8s.io/apimachinery/pkg/types"
        ctrl "sigs.k8s.io/controller-runtime"
        "sigs.k8s.io/controller-runtime/pkg/log"
)

// ApicastReconciler reconciles a Apicast object
type ApicastReconciler struct {
        workloads.WorkloadReconciler
        Log logr.Logger
}

// +kubebuilder:rbac:groups=saas.3scale.net,namespace=placeholder,resources=apicasts,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups=saas.3scale.net,namespace=placeholder,resources=apicasts/status,verbs=get;update;patch
// +kubebuilder:rbac:groups=saas.3scale.net,namespace=placeholder,resources=apicasts/finalizers,verbs=update
// +kubebuilder:rbac:groups="core",namespace=placeholder,resources=services,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups="apps",namespace=placeholder,resources=deployments,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups="monitoring.coreos.com",namespace=placeholder,resources=podmonitors,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups="autoscaling",namespace=placeholder,resources=horizontalpodautoscalers,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups="policy",namespace=placeholder,resources=poddisruptionbudgets,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups="integreatly.org",namespace=placeholder,resources=grafanadashboards,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups="marin3r.3scale.net",namespace=placeholder,resources=envoyconfigs,verbs=get;list;watch;create;update;patch;delete

// Reconcile is part of the main kubernetes reconciliation loop which aims to
// move the current state of the cluster closer to the desired state.
func (r *ApicastReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) <span class="cov0" title="0">{
        logger := r.Log.WithValues("name", req.Name, "namespace", req.Namespace)
        ctx = log.IntoContext(ctx, logger)

        instance := &amp;saasv1alpha1.Apicast{}
        key := types.NamespacedName{Name: req.Name, Namespace: req.Namespace}
        result, err := r.GetInstance(ctx, key, instance, nil, nil)
        if result != nil || err != nil </span><span class="cov0" title="0">{
                return *result, err
        }</span>

        // Apply defaults for reconcile but do not store them in the API
        <span class="cov0" title="0">instance.Default()

        gen, err := apicast.NewGenerator(instance.GetName(), instance.GetNamespace(), instance.Spec)
        if err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, err
        }</span>

        <span class="cov0" title="0">resources := gen.Resources()

        staging, err := r.NewDeploymentWorkload(&amp;gen.Staging, gen.CanaryStaging)
        if err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, err
        }</span>
        <span class="cov0" title="0">resources = append(resources, staging...)

        production, err := r.NewDeploymentWorkload(&amp;gen.Production, gen.CanaryProduction)
        if err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, err
        }</span>
        <span class="cov0" title="0">resources = append(resources, production...)

        err = r.ReconcileOwnedResources(ctx, instance, resources)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error(err, "unable to update owned resources")
                return ctrl.Result{}, err
        }</span>

        <span class="cov0" title="0">return ctrl.Result{}, nil</span>
}

// SetupWithManager sets up the controller with the Manager.
func (r *ApicastReconciler) SetupWithManager(mgr ctrl.Manager) error <span class="cov0" title="0">{
        return ctrl.NewControllerManagedBy(mgr).
                For(&amp;saasv1alpha1.Apicast{}).
                Owns(&amp;appsv1.Deployment{}).
                Owns(&amp;corev1.Service{}).
                Owns(&amp;policyv1.PodDisruptionBudget{}).
                Owns(&amp;autoscalingv2.HorizontalPodAutoscaler{}).
                Owns(&amp;monitoringv1.PodMonitor{}).
                Owns(&amp;grafanav1alpha1.GrafanaDashboard{}).
                Owns(&amp;marin3rv1alpha1.EnvoyConfig{}).
                Complete(r)
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">/*
Copyright 2021.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package controllers

import (
        "context"

        basereconciler "github.com/3scale-ops/basereconciler/reconciler"
        saasv1alpha1 "github.com/3scale/saas-operator/api/v1alpha1"
        "github.com/3scale/saas-operator/pkg/generators/autossl"
        "github.com/3scale/saas-operator/pkg/reconcilers/workloads"
        "github.com/go-logr/logr"
        grafanav1alpha1 "github.com/grafana-operator/grafana-operator/v4/api/integreatly/v1alpha1"
        monitoringv1 "github.com/prometheus-operator/prometheus-operator/pkg/apis/monitoring/v1"
        appsv1 "k8s.io/api/apps/v1"
        autoscalingv2 "k8s.io/api/autoscaling/v2"
        corev1 "k8s.io/api/core/v1"
        policyv1 "k8s.io/api/policy/v1"
        "k8s.io/apimachinery/pkg/types"
        ctrl "sigs.k8s.io/controller-runtime"
        "sigs.k8s.io/controller-runtime/pkg/log"
)

// AutoSSLReconciler reconciles a AutoSSL object
type AutoSSLReconciler struct {
        workloads.WorkloadReconciler
        Log logr.Logger
}

// +kubebuilder:rbac:groups=saas.3scale.net,namespace=placeholder,resources=autossls,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups=saas.3scale.net,namespace=placeholder,resources=autossls/status,verbs=get;update;patch
// +kubebuilder:rbac:groups=saas.3scale.net,namespace=placeholder,resources=autossls/finalizers,verbs=update
// +kubebuilder:rbac:groups="core",namespace=placeholder,resources=services,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups="apps",namespace=placeholder,resources=deployments,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups="monitoring.coreos.com",namespace=placeholder,resources=podmonitors,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups="autoscaling",namespace=placeholder,resources=horizontalpodautoscalers,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups="policy",namespace=placeholder,resources=poddisruptionbudgets,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups="integreatly.org",namespace=placeholder,resources=grafanadashboards,verbs=get;list;watch;create;update;patch;delete

// Reconcile is part of the main kubernetes reconciliation loop which aims to
// move the current state of the cluster closer to the desired state.
func (r *AutoSSLReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) <span class="cov0" title="0">{
        logger := r.Log.WithValues("name", req.Name, "namespace", req.Namespace)
        ctx = log.IntoContext(ctx, logger)

        instance := &amp;saasv1alpha1.AutoSSL{}
        key := types.NamespacedName{Name: req.Name, Namespace: req.Namespace}
        result, err := r.GetInstance(ctx, key, instance, nil, nil)
        if result != nil || err != nil </span><span class="cov0" title="0">{
                return *result, err
        }</span>

        // Apply defaults for reconcile but do not store them in the API
        <span class="cov0" title="0">instance.Default()

        gen, err := autossl.NewGenerator(
                instance.GetName(),
                instance.GetNamespace(),
                instance.Spec,
        )
        if err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, err
        }</span>

        // Shared resources
        <span class="cov0" title="0">resources := []basereconciler.Resource{
                gen.GrafanaDashboard(),
        }

        // Workload resources
        workload, err := r.NewDeploymentWorkload(&amp;gen, gen.Canary)
        if err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, err
        }</span>
        <span class="cov0" title="0">resources = append(resources, workload...)

        err = r.ReconcileOwnedResources(ctx, instance, resources)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error(err, "unable to update owned resources")
                return ctrl.Result{}, err
        }</span>

        <span class="cov0" title="0">return ctrl.Result{}, nil</span>
}

// SetupWithManager sets up the controller with the Manager.
func (r *AutoSSLReconciler) SetupWithManager(mgr ctrl.Manager) error <span class="cov0" title="0">{
        return ctrl.NewControllerManagedBy(mgr).
                For(&amp;saasv1alpha1.AutoSSL{}).
                Owns(&amp;appsv1.Deployment{}).
                Owns(&amp;corev1.Service{}).
                Owns(&amp;policyv1.PodDisruptionBudget{}).
                Owns(&amp;autoscalingv2.HorizontalPodAutoscaler{}).
                Owns(&amp;monitoringv1.PodMonitor{}).
                Owns(&amp;grafanav1alpha1.GrafanaDashboard{}).
                Complete(r)
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">/*
Copyright 2021.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package controllers

import (
        "context"

        marin3rv1alpha1 "github.com/3scale-ops/marin3r/apis/marin3r/v1alpha1"
        saasv1alpha1 "github.com/3scale/saas-operator/api/v1alpha1"
        "github.com/3scale/saas-operator/pkg/generators/backend"
        "github.com/3scale/saas-operator/pkg/reconcilers/workloads"
        externalsecretsv1beta1 "github.com/external-secrets/external-secrets/apis/externalsecrets/v1beta1"
        "github.com/go-logr/logr"
        grafanav1alpha1 "github.com/grafana-operator/grafana-operator/v4/api/integreatly/v1alpha1"
        monitoringv1 "github.com/prometheus-operator/prometheus-operator/pkg/apis/monitoring/v1"
        appsv1 "k8s.io/api/apps/v1"
        autoscalingv2 "k8s.io/api/autoscaling/v2"
        corev1 "k8s.io/api/core/v1"
        policyv1 "k8s.io/api/policy/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/types"
        ctrl "sigs.k8s.io/controller-runtime"
        "sigs.k8s.io/controller-runtime/pkg/log"
        "sigs.k8s.io/controller-runtime/pkg/source"
)

// BackendReconciler reconciles a Backend object
type BackendReconciler struct {
        workloads.WorkloadReconciler
        Log logr.Logger
}

// +kubebuilder:rbac:groups=saas.3scale.net,namespace=placeholder,resources=backends,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups=saas.3scale.net,namespace=placeholder,resources=backends/status,verbs=get;update;patch
// +kubebuilder:rbac:groups=saas.3scale.net,namespace=placeholder,resources=backends/finalizers,verbs=update
// +kubebuilder:rbac:groups="core",namespace=placeholder,resources=services,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups="core",namespace=placeholder,resources=secrets,verbs=get;list;watch
// +kubebuilder:rbac:groups="apps",namespace=placeholder,resources=deployments,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups="monitoring.coreos.com",namespace=placeholder,resources=podmonitors,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups="autoscaling",namespace=placeholder,resources=horizontalpodautoscalers,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups="policy",namespace=placeholder,resources=poddisruptionbudgets,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups="integreatly.org",namespace=placeholder,resources=grafanadashboards,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups="external-secrets.io",namespace=placeholder,resources=externalsecrets,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups="marin3r.3scale.net",namespace=placeholder,resources=envoyconfigs,verbs=get;list;watch;create;update;patch;delete

// Reconcile is part of the main kubernetes reconciliation loop which aims to
// move the current state of the cluster closer to the desired state.
func (r *BackendReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) <span class="cov0" title="0">{
        logger := r.Log.WithValues("name", req.Name, "namespace", req.Namespace)
        ctx = log.IntoContext(ctx, logger)

        instance := &amp;saasv1alpha1.Backend{}
        key := types.NamespacedName{Name: req.Name, Namespace: req.Namespace}
        result, err := r.GetInstance(ctx, key, instance, nil, nil)
        if result != nil || err != nil </span><span class="cov0" title="0">{
                return *result, err
        }</span>

        // Apply defaults for reconcile but do not store them in the API
        <span class="cov0" title="0">instance.Default()

        gen, err := backend.NewGenerator(instance.GetName(), instance.GetNamespace(), instance.Spec)
        if err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, err
        }</span>

        // Shared resources
        <span class="cov0" title="0">resources := gen.Resources()

        // Listener resources
        listener_resources, err := r.NewDeploymentWorkload(&amp;gen.Listener, gen.CanaryListener)
        if err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, err
        }</span>
        <span class="cov0" title="0">resources = append(resources, listener_resources...)

        // Worker resources
        worker_resources, err := r.NewDeploymentWorkload(&amp;gen.Worker, gen.CanaryWorker)
        if err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, err
        }</span>
        <span class="cov0" title="0">resources = append(resources, worker_resources...)

        // Cron resources
        cron_resources, err := r.NewDeploymentWorkload(&amp;gen.Cron, nil)
        if err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, err
        }</span>
        <span class="cov0" title="0">resources = append(resources, cron_resources...)

        // Reconcile all resources
        err = r.ReconcileOwnedResources(ctx, instance, resources)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error(err, "unable to reconcile owned resources")
                return ctrl.Result{}, err
        }</span>

        <span class="cov0" title="0">return ctrl.Result{}, nil</span>
}

// SetupWithManager sets up the controller with the Manager.
func (r *BackendReconciler) SetupWithManager(mgr ctrl.Manager) error <span class="cov0" title="0">{
        return ctrl.NewControllerManagedBy(mgr).
                For(&amp;saasv1alpha1.Backend{}).
                Owns(&amp;appsv1.Deployment{}).
                Owns(&amp;corev1.Service{}).
                Owns(&amp;policyv1.PodDisruptionBudget{}).
                Owns(&amp;autoscalingv2.HorizontalPodAutoscaler{}).
                Owns(&amp;monitoringv1.PodMonitor{}).
                Owns(&amp;externalsecretsv1beta1.ExternalSecret{}).
                Owns(&amp;grafanav1alpha1.GrafanaDashboard{}).
                Owns(&amp;marin3rv1alpha1.EnvoyConfig{}).
                Watches(&amp;source.Kind{Type: &amp;corev1.Secret{TypeMeta: metav1.TypeMeta{Kind: "Secret"}}},
                        r.SecretEventHandler(&amp;saasv1alpha1.BackendList{}, r.Log)).
                Complete(r)
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">/*
Copyright 2021.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package controllers

import (
        "context"

        basereconciler "github.com/3scale-ops/basereconciler/reconciler"
        saasv1alpha1 "github.com/3scale/saas-operator/api/v1alpha1"
        "github.com/3scale/saas-operator/pkg/generators/corsproxy"
        "github.com/3scale/saas-operator/pkg/reconcilers/workloads"
        externalsecretsv1beta1 "github.com/external-secrets/external-secrets/apis/externalsecrets/v1beta1"
        "github.com/go-logr/logr"
        grafanav1alpha1 "github.com/grafana-operator/grafana-operator/v4/api/integreatly/v1alpha1"
        monitoringv1 "github.com/prometheus-operator/prometheus-operator/pkg/apis/monitoring/v1"
        appsv1 "k8s.io/api/apps/v1"
        autoscalingv2 "k8s.io/api/autoscaling/v2"
        corev1 "k8s.io/api/core/v1"
        policyv1 "k8s.io/api/policy/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/types"
        ctrl "sigs.k8s.io/controller-runtime"
        "sigs.k8s.io/controller-runtime/pkg/log"
        "sigs.k8s.io/controller-runtime/pkg/source"
)

// CORSProxyReconciler reconciles a CORSProxy object
type CORSProxyReconciler struct {
        workloads.WorkloadReconciler
        Log logr.Logger
}

// +kubebuilder:rbac:groups=saas.3scale.net,namespace=placeholder,resources=corsproxies,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups=saas.3scale.net,namespace=placeholder,resources=corsproxies/status,verbs=get;update;patch
// +kubebuilder:rbac:groups=saas.3scale.net,namespace=placeholder,resources=corsproxies/finalizers,verbs=update
// +kubebuilder:rbac:groups="core",namespace=placeholder,resources=services,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups="core",namespace=placeholder,resources=secrets,verbs=get;list;watch
// +kubebuilder:rbac:groups="apps",namespace=placeholder,resources=deployments,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups="monitoring.coreos.com",namespace=placeholder,resources=podmonitors,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups="autoscaling",namespace=placeholder,resources=horizontalpodautoscalers,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups="policy",namespace=placeholder,resources=poddisruptionbudgets,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups="integreatly.org",namespace=placeholder,resources=grafanadashboards,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups="external-secrets.io",namespace=placeholder,resources=externalsecrets,verbs=get;list;watch;create;update;patch;delete

// Reconcile is part of the main kubernetes reconciliation loop which aims to
// move the current state of the cluster closer to the desired state.
func (r *CORSProxyReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) <span class="cov0" title="0">{
        logger := r.Log.WithValues("name", req.Name, "namespace", req.Namespace)
        ctx = log.IntoContext(ctx, logger)

        instance := &amp;saasv1alpha1.CORSProxy{}
        key := types.NamespacedName{Name: req.Name, Namespace: req.Namespace}
        result, err := r.GetInstance(ctx, key, instance, nil, nil)
        if result != nil || err != nil </span><span class="cov0" title="0">{
                return *result, err
        }</span>

        // Apply defaults for reconcile but do not store them in the API
        <span class="cov0" title="0">instance.Default()

        gen := corsproxy.NewGenerator(
                instance.GetName(),
                instance.GetNamespace(),
                instance.Spec,
        )

        resources := []basereconciler.Resource{
                gen.GrafanaDashboard(),
                gen.ExternalSecret(),
        }

        workload, err := r.NewDeploymentWorkload(&amp;gen, nil)
        if err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, err
        }</span>
        <span class="cov0" title="0">resources = append(resources, workload...)

        err = r.ReconcileOwnedResources(ctx, instance, resources)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error(err, "unable to reconcile owned resources")
                return ctrl.Result{}, err
        }</span>

        <span class="cov0" title="0">return ctrl.Result{}, nil</span>
}

// SetupWithManager sets up the controller with the Manager.
func (r *CORSProxyReconciler) SetupWithManager(mgr ctrl.Manager) error <span class="cov0" title="0">{
        return ctrl.NewControllerManagedBy(mgr).
                For(&amp;saasv1alpha1.CORSProxy{}).
                Owns(&amp;appsv1.Deployment{}).
                Owns(&amp;corev1.Service{}).
                Owns(&amp;policyv1.PodDisruptionBudget{}).
                Owns(&amp;autoscalingv2.HorizontalPodAutoscaler{}).
                Owns(&amp;monitoringv1.PodMonitor{}).
                Owns(&amp;externalsecretsv1beta1.ExternalSecret{}).
                Owns(&amp;grafanav1alpha1.GrafanaDashboard{}).
                Watches(&amp;source.Kind{Type: &amp;corev1.Secret{TypeMeta: metav1.TypeMeta{Kind: "Secret"}}},
                        r.SecretEventHandler(&amp;saasv1alpha1.CORSProxyList{}, r.Log)).
                Complete(r)
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">/*
Copyright 2021.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package controllers

import (
        "context"

        marin3rv1alpha1 "github.com/3scale-ops/marin3r/apis/marin3r/v1alpha1"
        saasv1alpha1 "github.com/3scale/saas-operator/api/v1alpha1"
        "github.com/3scale/saas-operator/pkg/generators/echoapi"
        "github.com/3scale/saas-operator/pkg/reconcilers/workloads"
        "github.com/go-logr/logr"
        grafanav1alpha1 "github.com/grafana-operator/grafana-operator/v4/api/integreatly/v1alpha1"
        monitoringv1 "github.com/prometheus-operator/prometheus-operator/pkg/apis/monitoring/v1"
        appsv1 "k8s.io/api/apps/v1"
        autoscalingv2 "k8s.io/api/autoscaling/v2"
        corev1 "k8s.io/api/core/v1"
        policyv1 "k8s.io/api/policy/v1"
        "k8s.io/apimachinery/pkg/types"
        ctrl "sigs.k8s.io/controller-runtime"
        "sigs.k8s.io/controller-runtime/pkg/log"
)

// EchoAPIReconciler reconciles a EchoAPI object
type EchoAPIReconciler struct {
        workloads.WorkloadReconciler
        Log logr.Logger
}

// +kubebuilder:rbac:groups=saas.3scale.net,namespace=placeholder,resources=echoapis,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups=saas.3scale.net,namespace=placeholder,resources=echoapis/status,verbs=get;update;patch
// +kubebuilder:rbac:groups=saas.3scale.net,namespace=placeholder,resources=echoapis/finalizers,verbs=update
// +kubebuilder:rbac:groups="core",namespace=placeholder,resources=services,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups="apps",namespace=placeholder,resources=deployments,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups="monitoring.coreos.com",namespace=placeholder,resources=podmonitors,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups="autoscaling",namespace=placeholder,resources=horizontalpodautoscalers,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups="policy",namespace=placeholder,resources=poddisruptionbudgets,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups="marin3r.3scale.net",namespace=placeholder,resources=envoyconfigs,verbs=get;list;watch;create;update;patch;delete

// Reconcile is part of the main kubernetes reconciliation loop which aims to
// move the current state of the cluster closer to the desired state.
func (r *EchoAPIReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) <span class="cov0" title="0">{
        logger := r.Log.WithValues("name", req.Name, "namespace", req.Namespace)
        ctx = log.IntoContext(ctx, logger)

        instance := &amp;saasv1alpha1.EchoAPI{}
        key := types.NamespacedName{Name: req.Name, Namespace: req.Namespace}
        result, err := r.GetInstance(ctx, key, instance, nil, nil)
        if result != nil || err != nil </span><span class="cov0" title="0">{
                return *result, err
        }</span>

        // Apply defaults for reconcile but do not store them in the API
        <span class="cov0" title="0">instance.Default()

        gen := echoapi.NewGenerator(
                instance.GetName(),
                instance.GetNamespace(),
                instance.Spec,
        )

        resources, err := r.NewDeploymentWorkload(&amp;gen, nil)
        if err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, err
        }</span>

        <span class="cov0" title="0">err = r.ReconcileOwnedResources(ctx, instance, resources)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error(err, "unable to update owned resources")
                return ctrl.Result{}, err
        }</span>

        <span class="cov0" title="0">return ctrl.Result{}, nil</span>
}

// SetupWithManager sets up the controller with the Manager.
func (r *EchoAPIReconciler) SetupWithManager(mgr ctrl.Manager) error <span class="cov0" title="0">{
        return ctrl.NewControllerManagedBy(mgr).
                For(&amp;saasv1alpha1.EchoAPI{}).
                Owns(&amp;appsv1.Deployment{}).
                Owns(&amp;corev1.Service{}).
                Owns(&amp;policyv1.PodDisruptionBudget{}).
                Owns(&amp;autoscalingv2.HorizontalPodAutoscaler{}).
                Owns(&amp;monitoringv1.PodMonitor{}).
                Owns(&amp;grafanav1alpha1.GrafanaDashboard{}).
                Owns(&amp;marin3rv1alpha1.EnvoyConfig{}).
                Complete(r)
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">/*
Copyright 2021.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package controllers

import (
        "context"

        basereconciler "github.com/3scale-ops/basereconciler/reconciler"
        saasv1alpha1 "github.com/3scale/saas-operator/api/v1alpha1"
        "github.com/3scale/saas-operator/pkg/generators/mappingservice"
        "github.com/3scale/saas-operator/pkg/reconcilers/workloads"
        externalsecretsv1beta1 "github.com/external-secrets/external-secrets/apis/externalsecrets/v1beta1"
        "github.com/go-logr/logr"
        grafanav1alpha1 "github.com/grafana-operator/grafana-operator/v4/api/integreatly/v1alpha1"
        monitoringv1 "github.com/prometheus-operator/prometheus-operator/pkg/apis/monitoring/v1"
        appsv1 "k8s.io/api/apps/v1"
        autoscalingv2 "k8s.io/api/autoscaling/v2"
        corev1 "k8s.io/api/core/v1"
        policyv1 "k8s.io/api/policy/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/types"
        ctrl "sigs.k8s.io/controller-runtime"
        "sigs.k8s.io/controller-runtime/pkg/log"
        "sigs.k8s.io/controller-runtime/pkg/source"
)

// MappingServiceReconciler reconciles a MappingService object
type MappingServiceReconciler struct {
        workloads.WorkloadReconciler
        Log logr.Logger
}

// +kubebuilder:rbac:groups=saas.3scale.net,namespace=placeholder,resources=mappingservices,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups=saas.3scale.net,namespace=placeholder,resources=mappingservices/status,verbs=get;update;patch
// +kubebuilder:rbac:groups=saas.3scale.net,namespace=placeholder,resources=mappingservices/finalizers,verbs=update
// +kubebuilder:rbac:groups="core",namespace=placeholder,resources=services,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups="core",namespace=placeholder,resources=secrets,verbs=get;list;watch
// +kubebuilder:rbac:groups="apps",namespace=placeholder,resources=deployments,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups="monitoring.coreos.com",namespace=placeholder,resources=podmonitors,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups="autoscaling",namespace=placeholder,resources=horizontalpodautoscalers,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups="policy",namespace=placeholder,resources=poddisruptionbudgets,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups="integreatly.org",namespace=placeholder,resources=grafanadashboards,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups="external-secrets.io",namespace=placeholder,resources=externalsecrets,verbs=get;list;watch;create;update;patch;delete

// Reconcile is part of the main kubernetes reconciliation loop which aims to
// move the current state of the cluster closer to the desired state.
func (r *MappingServiceReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) <span class="cov0" title="0">{
        logger := r.Log.WithValues("name", req.Name, "namespace", req.Namespace)
        ctx = log.IntoContext(ctx, logger)

        instance := &amp;saasv1alpha1.MappingService{}
        key := types.NamespacedName{Name: req.Name, Namespace: req.Namespace}
        result, err := r.GetInstance(ctx, key, instance, nil, nil)
        if result != nil || err != nil </span><span class="cov0" title="0">{
                return *result, err
        }</span>

        // Apply defaults for reconcile but do not store them in the API
        <span class="cov0" title="0">instance.Default()

        gen := mappingservice.NewGenerator(
                instance.GetName(),
                instance.GetNamespace(),
                instance.Spec,
        )

        resources := []basereconciler.Resource{
                gen.GrafanaDashboard(),
                gen.ExternalSecret(),
        }

        workload, err := r.NewDeploymentWorkload(&amp;gen, nil)
        if err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, err
        }</span>
        <span class="cov0" title="0">resources = append(resources, workload...)

        err = r.ReconcileOwnedResources(ctx, instance, resources)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error(err, "unable to reconcile owned resources")
                return ctrl.Result{}, err
        }</span>

        <span class="cov0" title="0">return ctrl.Result{}, nil</span>
}

// SetupWithManager sets up the controller with the Manager.
func (r *MappingServiceReconciler) SetupWithManager(mgr ctrl.Manager) error <span class="cov0" title="0">{
        return ctrl.NewControllerManagedBy(mgr).
                For(&amp;saasv1alpha1.MappingService{}).
                Owns(&amp;appsv1.Deployment{}).
                Owns(&amp;corev1.Service{}).
                Owns(&amp;policyv1.PodDisruptionBudget{}).
                Owns(&amp;autoscalingv2.HorizontalPodAutoscaler{}).
                Owns(&amp;monitoringv1.PodMonitor{}).
                Owns(&amp;externalsecretsv1beta1.ExternalSecret{}).
                Owns(&amp;grafanav1alpha1.GrafanaDashboard{}).
                Watches(&amp;source.Kind{Type: &amp;corev1.Secret{TypeMeta: metav1.TypeMeta{Kind: "Secret"}}},
                        r.SecretEventHandler(&amp;saasv1alpha1.MappingServiceList{}, r.Log)).
                Complete(r)
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package controllers

import (
        basereconciler "github.com/3scale-ops/basereconciler/reconciler"
        marin3rv1alpha1 "github.com/3scale-ops/marin3r/apis/marin3r/v1alpha1"
        saasv1alpha1 "github.com/3scale/saas-operator/api/v1alpha1"
        externalsecretsv1beta1 "github.com/external-secrets/external-secrets/apis/externalsecrets/v1beta1"
        grafanav1alpha1 "github.com/grafana-operator/grafana-operator/v4/api/integreatly/v1alpha1"
        monitoringv1 "github.com/prometheus-operator/prometheus-operator/pkg/apis/monitoring/v1"
        appsv1 "k8s.io/api/apps/v1"
        autoscalingv2 "k8s.io/api/autoscaling/v2"
        corev1 "k8s.io/api/core/v1"
        policyv1 "k8s.io/api/policy/v1"
)

func init() <span class="cov8" title="1">{
        basereconciler.Config.AnnotationsDomain = saasv1alpha1.AnnotationsDomain
        basereconciler.Config.ResourcePruner = true
        basereconciler.Config.ManagedTypes = basereconciler.NewManagedTypes().
                Register(&amp;corev1.ServiceList{}).
                Register(&amp;corev1.ConfigMapList{}).
                Register(&amp;appsv1.DeploymentList{}).
                Register(&amp;appsv1.StatefulSetList{}).
                Register(&amp;externalsecretsv1beta1.ExternalSecretList{}).
                Register(&amp;grafanav1alpha1.GrafanaDashboardList{}).
                Register(&amp;autoscalingv2.HorizontalPodAutoscalerList{}).
                Register(&amp;policyv1.PodDisruptionBudgetList{}).
                Register(&amp;monitoringv1.PodMonitorList{}).
                Register(&amp;marin3rv1alpha1.EnvoyConfigList{})
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">/*
Copyright 2021.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package controllers

import (
        "context"
        "fmt"
        "time"

        basereconciler "github.com/3scale-ops/basereconciler/reconciler"
        saasv1alpha1 "github.com/3scale/saas-operator/api/v1alpha1"
        "github.com/3scale/saas-operator/pkg/generators/redisshard"
        "github.com/3scale/saas-operator/pkg/redis"
        "github.com/3scale/saas-operator/pkg/redis/crud/client"
        "github.com/go-logr/logr"
        appsv1 "k8s.io/api/apps/v1"
        corev1 "k8s.io/api/core/v1"
        "k8s.io/apimachinery/pkg/api/equality"
        "k8s.io/apimachinery/pkg/types"
        "k8s.io/utils/pointer"
        ctrl "sigs.k8s.io/controller-runtime"
        "sigs.k8s.io/controller-runtime/pkg/log"
)

// RedisShardReconciler reconciles a RedisShard object
type RedisShardReconciler struct {
        basereconciler.Reconciler
        Log logr.Logger
}

// +kubebuilder:rbac:groups=saas.3scale.net,namespace=placeholder,resources=redisshards,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups=saas.3scale.net,namespace=placeholder,resources=redisshards/status,verbs=get;update;patch
// +kubebuilder:rbac:groups=saas.3scale.net,namespace=placeholder,resources=redisshards/finalizers,verbs=update
// +kubebuilder:rbac:groups="core",namespace=placeholder,resources=services,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups="core",namespace=placeholder,resources=pods,verbs=get;list;watch
// +kubebuilder:rbac:groups="apps",namespace=placeholder,resources=statefulsets,verbs=get;list;watch;create;update;patch;delete

// Reconcile is part of the main kubernetes reconciliation loop which aims to
// move the current state of the cluster closer to the desired state.
func (r *RedisShardReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) <span class="cov0" title="0">{
        logger := r.Log.WithValues("name", req.Name, "namespace", req.Namespace)
        ctx = log.IntoContext(ctx, logger)

        instance := &amp;saasv1alpha1.RedisShard{}
        key := types.NamespacedName{Name: req.Name, Namespace: req.Namespace}
        result, err := r.GetInstance(ctx, key, instance, nil, nil)
        if result != nil || err != nil </span><span class="cov0" title="0">{
                return *result, err
        }</span>

        // Apply defaults for reconcile but do not store them in the API
        <span class="cov0" title="0">instance.Default()

        gen := redisshard.NewGenerator(
                instance.GetName(),
                instance.GetNamespace(),
                instance.Spec,
        )

        if err := r.ReconcileOwnedResources(ctx, instance, gen.Resources()); err != nil </span><span class="cov0" title="0">{
                logger.Error(err, "unable to update owned resources")
                return ctrl.Result{}, err
        }</span>

        <span class="cov0" title="0">shard, result, err := r.setRedisRoles(ctx, types.NamespacedName{Name: req.Name, Namespace: req.Namespace},
                *instance.Spec.MasterIndex, *instance.Spec.SlaveCount+1, gen.ServiceName(), logger)

        // Close Redis clients
        defer shard.Cleanup(logger)

        if result != nil || err != nil </span><span class="cov0" title="0">{
                return *result, err
        }</span>

        <span class="cov0" title="0">if err = r.updateStatus(ctx, shard, instance, logger); err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, err
        }</span>

        <span class="cov0" title="0">return ctrl.Result{}, nil</span>
}

// SetupWithManager sets up the controller with the Manager.
func (r *RedisShardReconciler) SetupWithManager(mgr ctrl.Manager) error <span class="cov0" title="0">{
        return ctrl.NewControllerManagedBy(mgr).
                For(&amp;saasv1alpha1.RedisShard{}).
                Owns(&amp;appsv1.StatefulSet{}).
                Owns(&amp;corev1.Service{}).
                Owns(&amp;corev1.ConfigMap{}).
                Complete(r)
}</span>

func (r *RedisShardReconciler) setRedisRoles(ctx context.Context, key types.NamespacedName, masterIndex, replicas int32, serviceName string, log logr.Logger) (*redis.Shard, *ctrl.Result, error) <span class="cov0" title="0">{

        redisURLs := make([]string, replicas)
        for i := 0; i &lt; int(replicas); i++ </span><span class="cov0" title="0">{
                pod := &amp;corev1.Pod{}
                key := types.NamespacedName{Name: fmt.Sprintf("%s-%d", serviceName, i), Namespace: key.Namespace}
                err := r.Client.Get(ctx, key, pod)
                if err != nil </span><span class="cov0" title="0">{
                        return &amp;redis.Shard{Name: key.Name}, &amp;ctrl.Result{}, err
                }</span>

                <span class="cov0" title="0">redisURLs[i] = fmt.Sprintf("redis://%s:%d", pod.Status.PodIP, 6379)</span>
        }

        <span class="cov0" title="0">shard, err := redis.NewShard(key.Name, redisURLs)
        if err != nil </span><span class="cov0" title="0">{
                return shard, &amp;ctrl.Result{}, err
        }</span>

        <span class="cov0" title="0">_, err = shard.Init(ctx, masterIndex, log)
        if err != nil </span><span class="cov0" title="0">{
                log.Info("waiting for redis shard init")
                return shard, &amp;ctrl.Result{Requeue: true, RequeueAfter: 10 * time.Second}, nil
        }</span>

        <span class="cov0" title="0">return shard, nil, nil</span>
}

func (r *RedisShardReconciler) updateStatus(ctx context.Context, shard *redis.Shard, instance *saasv1alpha1.RedisShard, log logr.Logger) error <span class="cov0" title="0">{

        status := saasv1alpha1.RedisShardStatus{
                ShardNodes: &amp;saasv1alpha1.RedisShardNodes{Master: nil, Slaves: []string{}},
        }

        for _, server := range shard.Servers </span><span class="cov0" title="0">{
                if server.Role == client.Master </span><span class="cov0" title="0">{
                        status.ShardNodes.Master = pointer.StringPtr(server.Name)
                }</span> else<span class="cov0" title="0"> if server.Role == client.Slave </span><span class="cov0" title="0">{
                        status.ShardNodes.Slaves = append(status.ShardNodes.Slaves, server.Name)
                }</span>
        }
        <span class="cov0" title="0">if !equality.Semantic.DeepEqual(status, instance.Status) </span><span class="cov0" title="0">{
                instance.Status = status
                if err := r.Client.Status().Update(ctx, instance); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">/*
Copyright 2021.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package controllers

import (
        "context"
        "fmt"
        "time"

        basereconciler "github.com/3scale-ops/basereconciler/reconciler"
        saasv1alpha1 "github.com/3scale/saas-operator/api/v1alpha1"
        "github.com/3scale/saas-operator/pkg/generators/sentinel"
        "github.com/3scale/saas-operator/pkg/reconcilers/threads"
        "github.com/3scale/saas-operator/pkg/redis"
        "github.com/3scale/saas-operator/pkg/redis/events"
        "github.com/3scale/saas-operator/pkg/redis/metrics"
        "github.com/go-logr/logr"
        grafanav1alpha1 "github.com/grafana-operator/grafana-operator/v4/api/integreatly/v1alpha1"
        appsv1 "k8s.io/api/apps/v1"
        corev1 "k8s.io/api/core/v1"
        policyv1 "k8s.io/api/policy/v1"
        "k8s.io/apimachinery/pkg/api/equality"
        "k8s.io/apimachinery/pkg/types"
        "k8s.io/utils/pointer"
        ctrl "sigs.k8s.io/controller-runtime"
        "sigs.k8s.io/controller-runtime/pkg/handler"
        "sigs.k8s.io/controller-runtime/pkg/log"
        "sigs.k8s.io/controller-runtime/pkg/source"
)

// SentinelReconciler reconciles a Sentinel object
type SentinelReconciler struct {
        basereconciler.Reconciler
        Log            logr.Logger
        SentinelEvents threads.Manager
        Metrics        threads.Manager
}

// +kubebuilder:rbac:groups=saas.3scale.net,namespace=placeholder,resources=sentinels,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups=saas.3scale.net,namespace=placeholder,resources=sentinels/status,verbs=get;update;patch
// +kubebuilder:rbac:groups=saas.3scale.net,namespace=placeholder,resources=sentinels/finalizers,verbs=update
// +kubebuilder:rbac:groups="core",namespace=placeholder,resources=services,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups="apps",namespace=placeholder,resources=statefulsets,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups="monitoring.coreos.com",namespace=placeholder,resources=podmonitors,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups="policy",namespace=placeholder,resources=poddisruptionbudgets,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups="integreatly.org",namespace=placeholder,resources=grafanadashboards,verbs=get;list;watch;create;update;patch;delete

// Reconcile is part of the main kubernetes reconciliation loop which aims to
// move the current state of the cluster closer to the desired state.
func (r *SentinelReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) <span class="cov0" title="0">{
        logger := r.Log.WithValues("name", req.Name, "namespace", req.Namespace)
        ctx = log.IntoContext(ctx, logger)

        instance := &amp;saasv1alpha1.Sentinel{}
        key := types.NamespacedName{Name: req.Name, Namespace: req.Namespace}
        result, err := r.GetInstance(ctx,
                key,
                instance,
                pointer.String(saasv1alpha1.Finalizer),
                []func(){r.SentinelEvents.CleanupThreads(instance), r.Metrics.CleanupThreads(instance)})
        if result != nil || err != nil </span><span class="cov0" title="0">{
                return *result, err
        }</span>

        // Apply defaults for reconcile but do not store them in the API
        <span class="cov0" title="0">instance.Default()

        gen := sentinel.NewGenerator(
                instance.GetName(),
                instance.GetNamespace(),
                instance.Spec,
        )

        if err := r.ReconcileOwnedResources(ctx, instance, gen.Resources()); err != nil </span><span class="cov0" title="0">{
                logger.Error(err, "unable to update owned resources")
                return ctrl.Result{}, err
        }</span>

        // Create the redis-sentinel server pool
        <span class="cov0" title="0">sentinelPool, err := redis.NewSentinelPool(ctx, r.Client,
                types.NamespacedName{Name: gen.GetComponent(), Namespace: gen.GetNamespace()}, int(*instance.Spec.Replicas))

        // Close Redis clients
        defer sentinelPool.Cleanup(logger)

        if err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, err
        }</span>

        // Create the ShardedCluster objects that represents the redis servers to be monitored by sentinel
        <span class="cov0" title="0">shardedCluster, err := redis.NewShardedCluster(ctx, instance.Spec.Config.MonitoredShards, logger)

        // Close Redis clients
        defer shardedCluster.Cleanup(logger)

        if err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, err
        }</span>

        // Ensure all shards are being monitored
        <span class="cov0" title="0">allMonitored, err := sentinelPool.IsMonitoringShards(ctx, shardedCluster.GetShardNames())
        if err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, err
        }</span>
        <span class="cov0" title="0">if !allMonitored </span><span class="cov0" title="0">{
                if err := shardedCluster.Discover(ctx, logger); err != nil </span><span class="cov0" title="0">{
                        return ctrl.Result{}, err
                }</span>
                <span class="cov0" title="0">if _, err := sentinelPool.Monitor(ctx, shardedCluster); err != nil </span><span class="cov0" title="0">{
                        return ctrl.Result{}, err
                }</span>
        }

        // Reconcile sentinel the event watchers and metrics gatherers
        <span class="cov0" title="0">eventWatchers := make([]threads.RunnableThread, 0, len(gen.SentinelURIs()))
        metricsGatherers := make([]threads.RunnableThread, 0, len(gen.SentinelURIs()))
        for _, uri := range gen.SentinelURIs() </span><span class="cov0" title="0">{
                eventWatchers = append(eventWatchers, &amp;events.SentinelEventWatcher{
                        Instance:      instance,
                        SentinelURI:   uri,
                        ExportMetrics: true,
                        Topology:      &amp;shardedCluster,
                })
                metricsGatherers = append(metricsGatherers, &amp;metrics.SentinelMetricsGatherer{
                        RefreshInterval: *gen.Spec.Config.MetricsRefreshInterval,
                        SentinelURI:     uri,
                })
        }</span>
        <span class="cov0" title="0">if err := r.SentinelEvents.ReconcileThreads(ctx, instance, eventWatchers, logger.WithName("event-watcher")); err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, err
        }</span>
        <span class="cov0" title="0">if err := r.Metrics.ReconcileThreads(ctx, instance, metricsGatherers, logger.WithName("metrics-gatherer")); err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, err
        }</span>

        // Reconcile status of the Sentinel resource
        <span class="cov0" title="0">if err := r.reconcileStatus(ctx, instance, &amp;gen, sentinelPool, logger); err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, err
        }</span>

        <span class="cov0" title="0">return ctrl.Result{RequeueAfter: 30 * time.Second}, nil</span>
}

func (r *SentinelReconciler) reconcileStatus(ctx context.Context, instance *saasv1alpha1.Sentinel, gen *sentinel.Generator,
        spool redis.SentinelPool, log logr.Logger) error <span class="cov0" title="0">{

        monitoredShards, err := spool.MonitoredShards(ctx, saasv1alpha1.SentinelDefaultQuorum, redis.SlaveReadOnlyDiscoveryOpt, redis.SaveConfigDiscoveryOpt)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">replicas := int(*gen.Spec.Replicas)
        addressList := make([]string, 0, replicas)

        for i := 0; i &lt; replicas; i++ </span><span class="cov0" title="0">{
                key := types.NamespacedName{Name: gen.PodServiceName(i), Namespace: instance.GetNamespace()}
                svc := &amp;corev1.Service{}
                if err := r.Client.Get(ctx, key, svc); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">addressList = append(addressList, fmt.Sprintf("%s:%d", svc.Spec.ClusterIP, saasv1alpha1.SentinelPort))</span>
        }

        <span class="cov0" title="0">status := saasv1alpha1.SentinelStatus{
                Sentinels:       addressList,
                MonitoredShards: monitoredShards,
        }

        if !equality.Semantic.DeepEqual(status, instance.Status) </span><span class="cov0" title="0">{
                instance.Status = status
                if err := r.Client.Status().Update(ctx, instance); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// SetupWithManager sets up the controller with the Manager.
func (r *SentinelReconciler) SetupWithManager(mgr ctrl.Manager) error <span class="cov0" title="0">{
        return ctrl.NewControllerManagedBy(mgr).
                For(&amp;saasv1alpha1.Sentinel{}).
                Owns(&amp;appsv1.StatefulSet{}).
                Owns(&amp;corev1.Service{}).
                Owns(&amp;policyv1.PodDisruptionBudget{}).
                Owns(&amp;grafanav1alpha1.GrafanaDashboard{}).
                Owns(&amp;corev1.ConfigMap{}).
                Watches(&amp;source.Channel{Source: r.SentinelEvents.GetChannel()}, &amp;handler.EnqueueRequestForObject{}).
                Complete(r)
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">/*
Copyright 2021.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package controllers

import (
        "context"

        saasv1alpha1 "github.com/3scale/saas-operator/api/v1alpha1"
        "github.com/3scale/saas-operator/pkg/generators/system"
        "github.com/3scale/saas-operator/pkg/reconcilers/workloads"
        externalsecretsv1beta1 "github.com/external-secrets/external-secrets/apis/externalsecrets/v1beta1"
        "github.com/go-logr/logr"
        grafanav1alpha1 "github.com/grafana-operator/grafana-operator/v4/api/integreatly/v1alpha1"
        monitoringv1 "github.com/prometheus-operator/prometheus-operator/pkg/apis/monitoring/v1"
        appsv1 "k8s.io/api/apps/v1"
        autoscalingv2 "k8s.io/api/autoscaling/v2"
        corev1 "k8s.io/api/core/v1"
        policyv1 "k8s.io/api/policy/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/types"
        ctrl "sigs.k8s.io/controller-runtime"
        "sigs.k8s.io/controller-runtime/pkg/log"
        "sigs.k8s.io/controller-runtime/pkg/source"
)

// SystemReconciler reconciles a System object
type SystemReconciler struct {
        workloads.WorkloadReconciler
        Log logr.Logger
}

// +kubebuilder:rbac:groups=saas.3scale.net,namespace=placeholder,resources=systems,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups=saas.3scale.net,namespace=placeholder,resources=systems/status,verbs=get;update;patch
// +kubebuilder:rbac:groups=saas.3scale.net,namespace=placeholder,resources=systems/finalizers,verbs=update
// +kubebuilder:rbac:groups="core",namespace=placeholder,resources=services,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups="apps",namespace=placeholder,resources=deployments,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups="apps",namespace=placeholder,resources=statefulsets,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups="monitoring.coreos.com",namespace=placeholder,resources=podmonitors,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups="autoscaling",namespace=placeholder,resources=horizontalpodautoscalers,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups="policy",namespace=placeholder,resources=poddisruptionbudgets,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups="integreatly.org",namespace=placeholder,resources=grafanadashboards,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups="external-secrets.io",namespace=placeholder,resources=externalsecrets,verbs=get;list;watch;create;update;patch;delete

// Reconcile is part of the main kubernetes reconciliation loop which aims to
// move the current state of the cluster closer to the desired state.
func (r *SystemReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) <span class="cov0" title="0">{
        logger := r.Log.WithValues("name", req.Name, "namespace", req.Namespace)
        ctx = log.IntoContext(ctx, logger)

        instance := &amp;saasv1alpha1.System{}
        key := types.NamespacedName{Name: req.Name, Namespace: req.Namespace}
        result, err := r.GetInstance(ctx, key, instance, nil, nil)
        if result != nil || err != nil </span><span class="cov0" title="0">{
                return *result, err
        }</span>

        // Apply defaults for reconcile but do not store them in the API
        <span class="cov0" title="0">instance.Default()

        gen, err := system.NewGenerator(
                instance.GetName(),
                instance.GetNamespace(),
                instance.Spec,
        )
        if err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, err
        }</span>

        // Shared resources
        <span class="cov0" title="0">resources := append(gen.ExternalSecrets(), gen.GrafanaDashboard())

        // System APP
        app_resources, err := r.NewDeploymentWorkload(&amp;gen.App, gen.CanaryApp)
        if err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, err
        }</span>
        <span class="cov0" title="0">resources = append(resources, app_resources...)

        // Sidekiq Default resources
        sidekiq_default_resources, err := r.NewDeploymentWorkload(&amp;gen.SidekiqDefault, gen.CanarySidekiqDefault)
        if err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, err
        }</span>
        <span class="cov0" title="0">resources = append(resources, sidekiq_default_resources...)

        // Sidekiq Billing resources
        sidekiq_billing_resources, err := r.NewDeploymentWorkload(&amp;gen.SidekiqBilling, gen.CanarySidekiqBilling)
        if err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, err
        }</span>
        <span class="cov0" title="0">resources = append(resources, sidekiq_billing_resources...)

        // Sidekiq Low resources
        sidekiq_low_resources, err := r.NewDeploymentWorkload(&amp;gen.SidekiqLow, gen.CanarySidekiqLow)
        if err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, err
        }</span>
        <span class="cov0" title="0">resources = append(resources, sidekiq_low_resources...)

        // Sphinx resources
        resources = append(resources, gen.Sphinx.StatefulSetWithTraffic()...)

        // Console resources
        resources = append(resources, gen.Console.StatefulSet())

        err = r.ReconcileOwnedResources(ctx, instance, resources)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error(err, "unable to update owned resources")
                return ctrl.Result{}, err
        }</span>

        <span class="cov0" title="0">return ctrl.Result{}, nil</span>
}

// SetupWithManager sets up the controller with the Manager.
func (r *SystemReconciler) SetupWithManager(mgr ctrl.Manager) error <span class="cov0" title="0">{
        return ctrl.NewControllerManagedBy(mgr).
                For(&amp;saasv1alpha1.System{}).
                Owns(&amp;appsv1.Deployment{}).
                Owns(&amp;appsv1.StatefulSet{}).
                Owns(&amp;corev1.Service{}).
                Owns(&amp;policyv1.PodDisruptionBudget{}).
                Owns(&amp;autoscalingv2.HorizontalPodAutoscaler{}).
                Owns(&amp;monitoringv1.PodMonitor{}).
                Owns(&amp;externalsecretsv1beta1.ExternalSecret{}).
                Owns(&amp;grafanav1alpha1.GrafanaDashboard{}).
                Watches(&amp;source.Kind{Type: &amp;corev1.Secret{TypeMeta: metav1.TypeMeta{Kind: "Secret"}}},
                        r.SecretEventHandler(&amp;saasv1alpha1.SystemList{}, r.Log)).
                Complete(r)
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">/*
Copyright 2021.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package controllers

import (
        "context"
        "fmt"
        "reflect"
        "sync"
        "time"

        basereconciler "github.com/3scale-ops/basereconciler/reconciler"
        saasv1alpha1 "github.com/3scale/saas-operator/api/v1alpha1"
        "github.com/3scale/saas-operator/pkg/generators/twemproxyconfig"
        "github.com/3scale/saas-operator/pkg/reconcilers/threads"
        "github.com/3scale/saas-operator/pkg/redis/events"
        "github.com/3scale/saas-operator/pkg/util"
        "github.com/go-logr/logr"
        grafanav1alpha1 "github.com/grafana-operator/grafana-operator/v4/api/integreatly/v1alpha1"
        corev1 "k8s.io/api/core/v1"
        "k8s.io/apimachinery/pkg/api/errors"
        "k8s.io/apimachinery/pkg/types"
        "k8s.io/utils/pointer"
        ctrl "sigs.k8s.io/controller-runtime"
        "sigs.k8s.io/controller-runtime/pkg/client"
        "sigs.k8s.io/controller-runtime/pkg/controller/controllerutil"
        "sigs.k8s.io/controller-runtime/pkg/handler"
        "sigs.k8s.io/controller-runtime/pkg/log"
        "sigs.k8s.io/controller-runtime/pkg/source"
)

// TwemproxyConfigReconciler reconciles a TwemproxyConfig object
type TwemproxyConfigReconciler struct {
        basereconciler.Reconciler
        Log            logr.Logger
        SentinelEvents threads.Manager
}

// +kubebuilder:rbac:groups=saas.3scale.net,namespace=placeholder,resources=twemproxyconfigs,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups=saas.3scale.net,namespace=placeholder,resources=twemproxyconfigs/status,verbs=get;update;patch
// +kubebuilder:rbac:groups=saas.3scale.net,namespace=placeholder,resources=twemproxyconfigs/finalizers,verbs=update
// +kubebuilder:rbac:groups="core",namespace=placeholder,resources=configmaps,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups="core",namespace=placeholder,resources=pods,verbs=list;patch
// +kubebuilder:rbac:groups="integreatly.org",namespace=placeholder,resources=grafanadashboards,verbs=get;list;watch;create;update;patch;delete

// Reconcile is part of the main kubernetes reconciliation loop which aims to
// move the current state of the cluster closer to the desired state.
func (r *TwemproxyConfigReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) <span class="cov0" title="0">{
        logger := r.Log.WithValues("name", req.Name, "namespace", req.Namespace)
        ctx = log.IntoContext(ctx, logger)

        instance := &amp;saasv1alpha1.TwemproxyConfig{}
        key := types.NamespacedName{Name: req.Name, Namespace: req.Namespace}
        result, err := r.GetInstance(ctx, key, instance,
                pointer.String(saasv1alpha1.Finalizer),
                []func(){r.SentinelEvents.CleanupThreads(instance)})
        if result != nil || err != nil </span><span class="cov0" title="0">{
                return *result, err
        }</span>

        // Apply defaults for reconcile but do not store them in the API
        <span class="cov0" title="0">instance.Default()

        // Generate the ConfigMap
        gen, err := twemproxyconfig.NewGenerator(
                ctx, instance, r.Client, logger.WithName("generator"),
        )

        if err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, err
        }</span>
        <span class="cov0" title="0">cm, err := gen.ConfigMap().Build(ctx, r.Client)
        if err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, err
        }</span>

        // Reconcile the ConfigMap
        <span class="cov0" title="0">hash, err := r.reconcileConfigMap(ctx, instance, cm.(*corev1.ConfigMap), *instance.Spec.ReconcileServerPools, logger)
        if err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, err
        }</span>

        // Reconcile sync annotations in pods. This is done to force a change in the target
        // Pods annotations so the ConfigMap is re-synced inside the container. Otherwide kubelet
        // would re-sync the file asynchronously depending on its configured refresh time, which might
        // take several seconds.
        <span class="cov0" title="0">if err := r.reconcileSyncAnnotations(ctx, instance, hash, logger); err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, err
        }</span>

        // Reconcile sentinel event watchers
        <span class="cov0" title="0">eventWatchers := make([]threads.RunnableThread, 0, len(gen.Spec.SentinelURIs))
        for _, uri := range gen.Spec.SentinelURIs </span><span class="cov0" title="0">{
                eventWatchers = append(eventWatchers, &amp;events.SentinelEventWatcher{
                        Instance:      instance,
                        SentinelURI:   uri,
                        ExportMetrics: false,
                })
        }</span>
        <span class="cov0" title="0">r.SentinelEvents.ReconcileThreads(ctx, instance, eventWatchers, logger.WithName("event-watcher"))

        t := gen.GrafanaDashboard()
        gd, _ := t.Build(ctx, r.Client)
        controllerutil.SetControllerReference(instance, gd, r.Scheme)
        if err := t.ResourceReconciler(ctx, r.Client, gd); err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, err
        }</span>

        // Reconcile periodically in case some event is lost ...
        <span class="cov0" title="0">return ctrl.Result{RequeueAfter: 30 * time.Second}, nil</span>
}

func (r *TwemproxyConfigReconciler) reconcileConfigMap(ctx context.Context, owner client.Object,
        desired *corev1.ConfigMap, reconcileData bool, log logr.Logger) (string, error) <span class="cov0" title="0">{
        logger := log.WithValues("kind", "ConfigMap", "resource", desired.GetName())

        current := &amp;corev1.ConfigMap{}
        err := r.Client.Get(ctx, util.ObjectKey(desired), current)
        if err != nil </span><span class="cov0" title="0">{
                if errors.IsNotFound(err) </span><span class="cov0" title="0">{
                        // Create
                        if err := controllerutil.SetControllerReference(owner, desired, r.Scheme); err != nil </span><span class="cov0" title="0">{
                                return "", err
                        }</span>
                        <span class="cov0" title="0">if err := r.Client.Create(ctx, desired); err != nil </span><span class="cov0" title="0">{
                                return "", err
                        }</span>
                        <span class="cov0" title="0">logger.Info("created ConfigMap")
                        return util.Hash(desired.Data), nil</span>
                }
                <span class="cov0" title="0">return "", err</span>
        }

        <span class="cov0" title="0">if reconcileData </span><span class="cov0" title="0">{
                // Compare .data field of both ConfigMaps and patch if required.
                // We use patch to avoid failures due to having an older version
                // of the configmap so the config changes are propagated faster.
                if !reflect.DeepEqual(desired.Data, current.Data) </span><span class="cov0" title="0">{
                        patch := client.MergeFrom(current.DeepCopy())
                        current.Data = desired.Data
                        if err := r.Client.Patch(ctx, current, patch); err != nil </span><span class="cov0" title="0">{
                                logger.Error(err, "unable to patch ConfigMap")
                                return "", err
                        }</span>
                        <span class="cov0" title="0">logger.Info("patched ConfigMap")</span>
                }
        }

        <span class="cov0" title="0">return util.Hash(current.Data), nil</span>
}

func (r *TwemproxyConfigReconciler) reconcileSyncAnnotations(ctx context.Context,
        instance *saasv1alpha1.TwemproxyConfig, hash string, log logr.Logger) error <span class="cov0" title="0">{

        podList := &amp;corev1.PodList{}
        if err := r.Client.List(ctx, podList, instance.PodSyncSelector(),
                client.InNamespace(instance.GetNamespace())); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">failures := util.MultiError{}
        errCh := make(chan error)
        innerCtx, cancel := context.WithTimeout(ctx, 5*time.Second)
        var wg sync.WaitGroup

        // listen the error channel for errors
        go func() </span><span class="cov0" title="0">{
                for </span><span class="cov0" title="0">{
                        select </span>{
                        case err := &lt;-errCh:<span class="cov0" title="0">
                                failures = append(failures, err)</span>
                        case &lt;-innerCtx.Done():<span class="cov0" title="0">
                                return</span>
                        }
                }
        }()

        // Patch the Pods concurrently
        <span class="cov0" title="0">for _, pod := range podList.Items </span><span class="cov0" title="0">{
                wg.Add(1)
                go func(pod corev1.Pod) </span><span class="cov0" title="0">{
                        r.syncPod(innerCtx, pod, hash, errCh, log)
                        wg.Done()
                }</span>(pod)
        }

        <span class="cov0" title="0">wg.Wait()
        cancel()
        if len(failures) &gt; 0 </span><span class="cov0" title="0">{
                return failures
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (r *TwemproxyConfigReconciler) syncPod(ctx context.Context, pod corev1.Pod, hash string, errCh chan&lt;- error, log logr.Logger) <span class="cov0" title="0">{
        annotatedHash, ok := pod.GetAnnotations()[saasv1alpha1.TwemproxySyncAnnotationKey]
        if !ok || annotatedHash != hash </span><span class="cov0" title="0">{
                patch := client.MergeFrom(pod.DeepCopy())
                if pod.GetAnnotations() != nil </span><span class="cov0" title="0">{
                        pod.ObjectMeta.Annotations[saasv1alpha1.TwemproxySyncAnnotationKey] = hash
                }</span> else<span class="cov0" title="0"> {
                        pod.ObjectMeta.Annotations = map[string]string{
                                saasv1alpha1.TwemproxySyncAnnotationKey: hash,
                        }
                }</span>

                <span class="cov0" title="0">if err := r.Client.Patch(ctx, &amp;pod, patch); err != nil </span><span class="cov0" title="0">{
                        errCh &lt;- err
                }</span>
                <span class="cov0" title="0">log.V(1).Info(fmt.Sprintf("configmap re-sync forced in target pod %s", util.ObjectKey(&amp;pod)))</span>
        }
}

// SetupWithManager sets up the controller with the Manager.
func (r *TwemproxyConfigReconciler) SetupWithManager(mgr ctrl.Manager) error <span class="cov0" title="0">{
        return ctrl.NewControllerManagedBy(mgr).
                For(&amp;saasv1alpha1.TwemproxyConfig{}).
                Owns(&amp;corev1.ConfigMap{}).
                Owns(&amp;grafanav1alpha1.GrafanaDashboard{}).
                Watches(&amp;source.Channel{Source: r.SentinelEvents.GetChannel()}, &amp;handler.EnqueueRequestForObject{}).
                Complete(r)
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">/*
Copyright 2021.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package controllers

import (
        "context"

        saasv1alpha1 "github.com/3scale/saas-operator/api/v1alpha1"
        "github.com/3scale/saas-operator/pkg/generators/zync"
        "github.com/3scale/saas-operator/pkg/reconcilers/workloads"
        externalsecretsv1beta1 "github.com/external-secrets/external-secrets/apis/externalsecrets/v1beta1"
        "github.com/go-logr/logr"
        grafanav1alpha1 "github.com/grafana-operator/grafana-operator/v4/api/integreatly/v1alpha1"
        monitoringv1 "github.com/prometheus-operator/prometheus-operator/pkg/apis/monitoring/v1"
        appsv1 "k8s.io/api/apps/v1"
        autoscalingv2 "k8s.io/api/autoscaling/v2"
        corev1 "k8s.io/api/core/v1"
        policyv1 "k8s.io/api/policy/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/types"
        ctrl "sigs.k8s.io/controller-runtime"
        "sigs.k8s.io/controller-runtime/pkg/log"
        "sigs.k8s.io/controller-runtime/pkg/source"
)

// ZyncReconciler reconciles a Zync object
type ZyncReconciler struct {
        workloads.WorkloadReconciler
        Log logr.Logger
}

// +kubebuilder:rbac:groups=saas.3scale.net,namespace=placeholder,resources=zyncs,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups=saas.3scale.net,namespace=placeholder,resources=zyncs/status,verbs=get;update;patch
// +kubebuilder:rbac:groups=saas.3scale.net,namespace=placeholder,resources=zyncs/finalizers,verbs=update
// +kubebuilder:rbac:groups="core",namespace=placeholder,resources=services,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups="core",namespace=placeholder,resources=secrets,verbs=get;list;watch
// +kubebuilder:rbac:groups="apps",namespace=placeholder,resources=deployments,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups="monitoring.coreos.com",namespace=placeholder,resources=podmonitors,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups="autoscaling",namespace=placeholder,resources=horizontalpodautoscalers,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups="policy",namespace=placeholder,resources=poddisruptionbudgets,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups="integreatly.org",namespace=placeholder,resources=grafanadashboards,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups="external-secrets.io",namespace=placeholder,resources=externalsecrets,verbs=get;list;watch;create;update;patch;delete

// Reconcile is part of the main kubernetes reconciliation loop which aims to
// move the current state of the cluster closer to the desired state.
func (r *ZyncReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) <span class="cov0" title="0">{
        logger := r.Log.WithValues("name", req.Name, "namespace", req.Namespace)
        ctx = log.IntoContext(ctx, logger)

        instance := &amp;saasv1alpha1.Zync{}
        key := types.NamespacedName{Name: req.Name, Namespace: req.Namespace}
        result, err := r.GetInstance(ctx, key, instance, nil, nil)
        if result != nil || err != nil </span><span class="cov0" title="0">{
                return *result, err
        }</span>

        // Apply defaults for reconcile but do not store them in the API
        <span class="cov0" title="0">instance.Default()

        gen := zync.NewGenerator(
                instance.GetName(),
                instance.GetNamespace(),
                instance.Spec,
        )

        // Shared resources
        resources := gen.Resources()

        // Api resources
        api_resources, err := r.NewDeploymentWorkload(&amp;gen.API, nil)
        if err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, err
        }</span>
        <span class="cov0" title="0">resources = append(resources, api_resources...)

        // Que resources
        que_resources, err := r.NewDeploymentWorkload(&amp;gen.Que, nil)
        if err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, err
        }</span>
        <span class="cov0" title="0">resources = append(resources, que_resources...)

        // Reconcile all resources
        err = r.ReconcileOwnedResources(ctx, instance, resources)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error(err, "unable to reconcile owned resources")
                return ctrl.Result{}, err
        }</span>

        <span class="cov0" title="0">return ctrl.Result{}, nil</span>
}

// SetupWithManager sets up the controller with the Manager.
func (r *ZyncReconciler) SetupWithManager(mgr ctrl.Manager) error <span class="cov0" title="0">{
        return ctrl.NewControllerManagedBy(mgr).
                For(&amp;saasv1alpha1.Zync{}).
                Owns(&amp;appsv1.Deployment{}).
                Owns(&amp;corev1.Service{}).
                Owns(&amp;policyv1.PodDisruptionBudget{}).
                Owns(&amp;autoscalingv2.HorizontalPodAutoscaler{}).
                Owns(&amp;monitoringv1.PodMonitor{}).
                Owns(&amp;externalsecretsv1beta1.ExternalSecret{}).
                Owns(&amp;grafanav1alpha1.GrafanaDashboard{}).
                Watches(&amp;source.Kind{Type: &amp;corev1.Secret{TypeMeta: metav1.TypeMeta{Kind: "Secret"}}},
                        r.SecretEventHandler(&amp;saasv1alpha1.ZyncList{}, r.Log)).
                Complete(r)
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
